---
layout: post
title: Loading Legacy Content in an iFrame
date: 2011-09-05 07:00:38.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Technology
tags:
- iframe
- proxy
meta:
  yourls_shorturl: http://eam.me/g6
  _yoast_wpseo_metadesc: I needed to embed an old page from one server on a new website
    on another server. Thanks to jQuery and a proxy file, it was a piece of cake!
  yourls_tweeted: '1'
  _yoast_wpseo_metakeywords: jQuery, proxy, AJAX, iFrame
  _edit_last: '2'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1409880188;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:3471;}i:1;a:1:{s:2:"id";i:3111;}i:2;a:1:{s:2:"id";i:6223;}}}}
  keen_postview_count_this_30_days: '11'
  _wpghs_github_path: _posts/2011-09-05-loading-legacy-content-in-an-iframe.md
author:
  login: eamann
  email: eric@eamann.com
  display_name: Eric
  first_name: Eric
  last_name: Mann
permalink: "/tech/loading-legacy-content-in-an-iframe/"
---
<p>At my day job, I’m responsible for bringing our various web products up to modern standards.  Right now, that involves pulling our old website off a static, table-based system built with FrontPage and executing a new design using ASP.NET MVC 3.</p>
<p>It’s been a fun project so far, except for one major hang-up.</p>
<p>We have a legacy system our customers use to download content from our site.  The legacy system is a CGI script on the server that handles rudimentary authentication and presents a list of user-specific downloadable files.  Simple, straight-forward, but something we want to throw out entirely.</p>
<p>My <em>next</em> project will be to re-build this system from the ground up.  But for now, I needed to carry over the old content into the new website.  And this presented problems.</p>
<h2>Domain Issues</h2>
<p>First of all, the download system is hosted on the same domain as the website.  When we launch the new site, though, we’re moving it to a new server entirely – transitioning from a shared host somewhere to a VPS.  But we’re leaving the download system on the old host.</p>
<p>This means the new site needs to reference the old system by its IP address.  Not a problem for file download links; a <em>huge</em> problem for an iFrame.</p>
<p>The download system has the CSS and table-based layout of the old site hard-coded into the CGI.  When you view it through an iFrame on the new site, you see a page-within-a-page that looks, frankly, butt ugly.</p>
<p>If both pages were being served off the same domain, I could use jQuery to inject some styling into the iFrame and clean up the content.  With the new site on the real domain and the old download system on a naked IP address, though, no browser will let me do that.</p>
<p>They all scream about cross-site scripting vulnerabilities and throw out my code.</p>
<h2>Proxy Solution</h2>
<p>Instead of loading the remote site into an iFrame, I load a proxy from the same server.  Essentially, a script on the new server fetches the content from the old site and re-displays it.  This gets around the same-domain policy issue I had before and allows me to remove superfluous table designs and add new colors and images to the styling.</p>
<p>[cc lang="c#" width="580"]<br />
public partial class Proxy : System.Web.UI.Page<br />
{<br />
protected void Page_Load(object sender, EventArgs e)<br />
{<br />
var proxyURL = String.Empty;<br />
try<br />
{<br />
proxyURL = HttpUtility.UrlDecode(Request.QueryString["u"].ToString());<br />
}<br />
catch { }</p>
<p>if (proxyURL != string.Empty)<br />
{<br />
HttpWebRequest request = (HttpWebRequest)WebRequest.Create(proxyURL);<br />
request.Method = "GET";<br />
HttpWebResponse response = (HttpWebResponse)request.GetResponse();</p>
<p>if (response.StatusCode.ToString().ToLower() == "ok")<br />
{<br />
var contentType = response.ContentType;<br />
var content = response.GetResponseStream();<br />
var contentReader = new StreamReader(content);<br />
Response.ContentType = contentType;<br />
Response.Write(contentReader.ReadToEnd());<br />
}<br />
}<br />
}<br />
}<br />
[/cc]</p>
<p>Unfortunately, the embedded HTML generated by the CGI script is still submitting form callbacks to the old server … and breaking the iFrame in the process.</p>
<h2>Enter jQuery AJAX</h2>
<p>The final step to cleaning things up was to add a jQuery listener to the iFrame that intercepts all form clicks, postbacks, and any event that would track back to the old system and instead pass it on to the proxy file.</p>
<p>My proxy file essentially has two actions: “login” and default.  The default action requests the raw content from the old CGI file and delivers our user’s login form to the screen.  When a user enters information, it’s sent back to the proxy file via jQuery and invokes the “login” action.</p>
<p>[cc lang="javascript" width="580"]<br />
var iframe = $('#downloadcenter');</p>
<p>iframe.contents().find(':submit').click(function (e) {<br />
e.preventDefault();</p>
<p>var user = iframe.contents().find('input[name=Username]').val(),<br />
pass = iframe.contents().find('input[name=Password]').val();</p>
<p>$.ajax({<br />
url: '/Proxy.aspx?action=login&amp;user=' + user + '&amp;pass=' + pass,<br />
type: 'POST',<br />
success: function (data) {<br />
$('#downloadcenter').contents().find('body').html(data);<br />
}<br />
});<br />
});</p>
<p>[/cc]</p>
<p>The proxy file passes the user’s credentials on to the CGI file and returns any response (login failure or success) to the screen.</p>
<p>[cc lang="c#" width="580"]<br />
public partial class Proxy : System.Web.UI.Page<br />
{<br />
protected void Page_Load(object sender, EventArgs e)<br />
{<br />
var proxyURL = ConfigurationManager.AppSettings["DownloadCenterURI"];<br />
var action = String.Empty;<br />
try<br />
{<br />
action = HttpUtility.UrlDecode(Request.QueryString["action"].ToString());<br />
}<br />
catch { }</p>
<p>HttpWebRequest request;<br />
HttpWebResponse response;</p>
<p>switch (action)<br />
{<br />
// Log in a user<br />
case "login":<br />
var user = HttpUtility.UrlDecode(Request.QueryString["user"].ToString());<br />
var pass = HttpUtility.UrlDecode(Request.QueryString["pass"].ToString());</p>
<p>if (user.IsNullOrEmpty() || pass.IsNullOrEmpty()) goto default;</p>
<p>request = (HttpWebRequest)WebRequest.Create(proxyURL);<br />
request.Method = "POST";</p>
<p>var dataString = "Username=" + user + "&amp;Password=" + pass;<br />
var data = (new System.Text.ASCIIEncoding()).GetBytes(dataString);</p>
<p>request.ContentType = "application/x-www-form-encoded";<br />
request.ContentLength = data.Length;</p>
<p>var dataStream = request.GetRequestStream();<br />
dataStream.Write(data, 0, data.Length);<br />
dataStream.Close();</p>
<p>response = (HttpWebResponse)request.GetResponse();</p>
<p>if (response.StatusCode.ToString().ToLower() == "ok")<br />
{<br />
var contentType = response.ContentType;<br />
var content = response.GetResponseStream();<br />
var contentReader = new StreamReader(content);<br />
Response.ContentType = contentType;<br />
Response.Write(contentReader.ReadToEnd());<br />
}</p>
<p>break;<br />
// Present the login screen<br />
default:<br />
request = (HttpWebRequest)WebRequest.Create(proxyURL);<br />
request.Method = "GET";</p>
<p>response = (HttpWebResponse)request.GetResponse();</p>
<p>if (response.StatusCode.ToString().ToLower() == "ok")<br />
{<br />
var contentType = response.ContentType;<br />
var content = response.GetResponseStream();<br />
var contentReader = new StreamReader(content);<br />
Response.ContentType = contentType;<br />
Response.Write(contentReader.ReadToEnd());<br />
}<br />
break;<br />
}<br />
}<br />
}</p>
<p>[/cc]</p>
<p>It’s a nice trick that solves a major problem we were having with the new website.  Originally, we pushed our release schedule back by about a month so I could rebuild the download management system.  With the new embedded iFrame, we can launch the new site without worrying about a download overhaul just yet.</p>
<p>But it will be coming.  I guarantee that much.</p>
