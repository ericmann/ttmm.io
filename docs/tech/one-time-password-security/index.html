<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
        <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>One Time Password Security | Things that Matter Most</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="One Time Password Security" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="My day job has primarily consisted of migrating an old-school ASP.Net WebForms website to a new ASP.Net MVC application.  This has involved a massive layout/structure redesign, database overhaul, and a lot of custom coding. I&#39;m mostly happy with how I structured the MVC-based content management system.  It&#39;s very similar to WordPress ... only written in C# and using a MS SQL database for the back end.  It also borrows heavily from designs found in DotNetNuke, BlogEngine.NET, and just about every other CMS I&#39;ve ever used. But the trickiest - and coolest - part came when my boss asked that it be fully backwards compatible. Our flagship software application is heavily integrated with the web.  Users update their subscriptions through a web service.  Documents are downloaded from a webs service.  System updates are delivered through a web service. Unfortunately, all of this was set up on a legacy server that was physically in our office.  Since we&#39;re moving to a distributed content hosting system, we needed an easy way not just to retrieve the data (that&#39;s handled already) but to send updates to these webservices. It had to be secure. It had to be fast. It had to not be FTP. Last Time &#39;Round In my last job, I built a web service network that built off a traditional challenge-response authentication system.  Every client application accessed each web service on behalf of a specific user (with a username and password).  The client would ping the server and ask for a security token.  Then it would hash its credentials with the token and submit that hash along with the data. Effective ... but bulky. This older system required discrete user accounts be set up for every user.  It also required multiple HTTP transactions between systems - a HEAD request to get a token followed by a POST/GET/PUT/DELETE request to interact with data.  It worked, but was cumbersome.  The multiple transactions also opened us to man-in-the-middle attacks, so everything was necessarily SSL-encrypted. A New Paradigm This time, I elected to go with a simpler system that, oddly enough, is more secure. The client is issued an application name and secret key at its time of deployment - the server keeps track of these in a secured database.  The secret key is never exchanged over the wire. When a client sends a request, it also submits three pieces of information in the request headers: It&#39;s name A randomly-generated string A one-time password The one-time password is a hash of three things: The application&#39;s secret key The same randomly-generated string passed in the header The current system UNIX timestamp, divided by 15 This ensures the password is unique to the application, unique to the request, and only valid within a narrow time window. Why It Works The server independently re-creates the application&#39;s password by looking up the application&#39;s secret key and hashing it together with the random string passed in the request and the current system UNIX timestamp (divided by 15). The server will only accept requests for the current 15-second window and the immediately previous 15-second window. In addition, the server records the random string sent by the application and automatically rejects any duplicate requests. This leads to an authentication system that is: Unique to client applications but not necessarily to individual user accounts Incredibly fast - only one request is ever sent/received Not based on FTP What would you do to make the request more secure?" />
<meta property="og:description" content="My day job has primarily consisted of migrating an old-school ASP.Net WebForms website to a new ASP.Net MVC application.  This has involved a massive layout/structure redesign, database overhaul, and a lot of custom coding. I&#39;m mostly happy with how I structured the MVC-based content management system.  It&#39;s very similar to WordPress ... only written in C# and using a MS SQL database for the back end.  It also borrows heavily from designs found in DotNetNuke, BlogEngine.NET, and just about every other CMS I&#39;ve ever used. But the trickiest - and coolest - part came when my boss asked that it be fully backwards compatible. Our flagship software application is heavily integrated with the web.  Users update their subscriptions through a web service.  Documents are downloaded from a webs service.  System updates are delivered through a web service. Unfortunately, all of this was set up on a legacy server that was physically in our office.  Since we&#39;re moving to a distributed content hosting system, we needed an easy way not just to retrieve the data (that&#39;s handled already) but to send updates to these webservices. It had to be secure. It had to be fast. It had to not be FTP. Last Time &#39;Round In my last job, I built a web service network that built off a traditional challenge-response authentication system.  Every client application accessed each web service on behalf of a specific user (with a username and password).  The client would ping the server and ask for a security token.  Then it would hash its credentials with the token and submit that hash along with the data. Effective ... but bulky. This older system required discrete user accounts be set up for every user.  It also required multiple HTTP transactions between systems - a HEAD request to get a token followed by a POST/GET/PUT/DELETE request to interact with data.  It worked, but was cumbersome.  The multiple transactions also opened us to man-in-the-middle attacks, so everything was necessarily SSL-encrypted. A New Paradigm This time, I elected to go with a simpler system that, oddly enough, is more secure. The client is issued an application name and secret key at its time of deployment - the server keeps track of these in a secured database.  The secret key is never exchanged over the wire. When a client sends a request, it also submits three pieces of information in the request headers: It&#39;s name A randomly-generated string A one-time password The one-time password is a hash of three things: The application&#39;s secret key The same randomly-generated string passed in the header The current system UNIX timestamp, divided by 15 This ensures the password is unique to the application, unique to the request, and only valid within a narrow time window. Why It Works The server independently re-creates the application&#39;s password by looking up the application&#39;s secret key and hashing it together with the random string passed in the request and the current system UNIX timestamp (divided by 15). The server will only accept requests for the current 15-second window and the immediately previous 15-second window. In addition, the server records the random string sent by the application and automatically rejects any duplicate requests. This leads to an authentication system that is: Unique to client applications but not necessarily to individual user accounts Incredibly fast - only one request is ever sent/received Not based on FTP What would you do to make the request more secure?" />
<meta property="og:site_name" content="Things that Matter Most" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2011-09-29T10:00:30-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="One Time Password Security" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"One Time Password Security","dateModified":"2011-09-29T10:00:30-07:00","datePublished":"2011-09-29T10:00:30-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"/tech/one-time-password-security/"},"url":"/tech/one-time-password-security/","description":"My day job has primarily consisted of migrating an old-school ASP.Net WebForms website to a new ASP.Net MVC application.  This has involved a massive layout/structure redesign, database overhaul, and a lot of custom coding. I&#39;m mostly happy with how I structured the MVC-based content management system.  It&#39;s very similar to WordPress ... only written in C# and using a MS SQL database for the back end.  It also borrows heavily from designs found in DotNetNuke, BlogEngine.NET, and just about every other CMS I&#39;ve ever used. But the trickiest - and coolest - part came when my boss asked that it be fully backwards compatible. Our flagship software application is heavily integrated with the web.  Users update their subscriptions through a web service.  Documents are downloaded from a webs service.  System updates are delivered through a web service. Unfortunately, all of this was set up on a legacy server that was physically in our office.  Since we&#39;re moving to a distributed content hosting system, we needed an easy way not just to retrieve the data (that&#39;s handled already) but to send updates to these webservices. It had to be secure. It had to be fast. It had to not be FTP. Last Time &#39;Round In my last job, I built a web service network that built off a traditional challenge-response authentication system.  Every client application accessed each web service on behalf of a specific user (with a username and password).  The client would ping the server and ask for a security token.  Then it would hash its credentials with the token and submit that hash along with the data. Effective ... but bulky. This older system required discrete user accounts be set up for every user.  It also required multiple HTTP transactions between systems - a HEAD request to get a token followed by a POST/GET/PUT/DELETE request to interact with data.  It worked, but was cumbersome.  The multiple transactions also opened us to man-in-the-middle attacks, so everything was necessarily SSL-encrypted. A New Paradigm This time, I elected to go with a simpler system that, oddly enough, is more secure. The client is issued an application name and secret key at its time of deployment - the server keeps track of these in a secured database.  The secret key is never exchanged over the wire. When a client sends a request, it also submits three pieces of information in the request headers: It&#39;s name A randomly-generated string A one-time password The one-time password is a hash of three things: The application&#39;s secret key The same randomly-generated string passed in the header The current system UNIX timestamp, divided by 15 This ensures the password is unique to the application, unique to the request, and only valid within a narrow time window. Why It Works The server independently re-creates the application&#39;s password by looking up the application&#39;s secret key and hashing it together with the random string passed in the request and the current system UNIX timestamp (divided by 15). The server will only accept requests for the current 15-second window and the immediately previous 15-second window. In addition, the server records the random string sent by the application and automatically rejects any duplicate requests. This leads to an authentication system that is: Unique to client applications but not necessarily to individual user accounts Incredibly fast - only one request is ever sent/received Not based on FTP What would you do to make the request more secure?","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    

    <!-- Site Favicon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" type="image/png" />

    <!-- Font Embed Code -->
	<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,400i,600,600i|Karla:400,400i,700,700i" rel="stylesheet">

    <!-- CSS Styles -->
    <link href="/assets/css/style.css" rel="stylesheet">
</head>



<body class="layout-post">
    <div id="page" class="site">
        <header id="masthead" class="site-header">
    <div class="site-header-wrap">
        <div class="site-header-inside">

            <div class="site-branding">
                
                <p class="profile">
                    <a href="/">
                        <img src="/assets/images/authorimage.jpg" alt="'s Picture"
                            class="avatar" />
                    </a>
                </p>
                <div class="site-identity">
                    
                    <h1 class="site-title">
                        <a href="/">Things that Matter Most</a>
                    </h1>
                    
                    
                    <p class="site-description">Things that Matter Most</p>
                    
                </div><!-- .site-identity -->
                
                <button id="menu-toggle" class="menu-toggle"><span class="screen-reader-text">Main Menu</span><span
                        class="icon-menu" aria-hidden="true"></span></button>
            </div><!-- .site-branding -->

            <nav id="main-navigation" class="site-navigation" aria-label="Main Navigation">
                <div class="site-nav-wrap">
                    <div class="site-nav-inside">
                    <ul class="menu">
                        
                        
                        
                        <li class="menu-item "><a href="/">Home</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/about">About</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/contact">Contact Me</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/search">Search</a></li>
                        
                    </ul>
                    <p class="social-links">
    
    <a href="https://twitter.com/ericmann" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
    <a href="https://github.com/ericmann" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
    
    
    
    
    <a href="https://www.linkedin.com/in/ericallenmann" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
</p>
                    </div><!-- .site-nav-inside -->
                </div><!-- .site-nav-wrap -->
            </nav><!-- .site-navigation -->

        </div><!-- .site-header-inside -->
    </div><!-- .site-header-wrap -->
</header><!-- .site-header -->
        <div id="content" class="site-content fadeInDown delay_075s">
            <div class="inner-wide">
                <main id="main" class="site-main">

    <article class="post-full inner">

        <header class="post-header">
            <div class="post-meta">
                <time class="post-date" datetime="2011-09-29">
                    September 29, 2011
                </time>
            </div><!-- .post-meta -->
            <h1 class="post-title">One Time Password Security</h1>
        </header><!-- .post-header -->

        
        <div class="post-content">
            <p>My day job has primarily consisted of migrating an old-school <a href="http://msdn.microsoft.com/en-us/library/ms973868.aspx">ASP.Net WebForms</a> website to a new <a href="http://www.asp.net/mvc" target="_blank">ASP.Net MVC</a> application.  This has involved a massive layout/structure redesign, database overhaul, and a lot of custom coding.</p>
<p>I'm mostly happy with how I structured the MVC-based content management system.  It's very similar to <a href="http://wordpress.org" target="_blank">WordPress </a>... only written in C# and using a MS SQL database for the back end.  It also borrows heavily from designs found in <a href="http://www.dotnetnuke.com/" target="_blank">DotNetNuke</a>, <a href="http://www.dotnetblogengine.net/" target="_blank">BlogEngine.NET</a>, and just about every other CMS I've ever used.</p>
<p>But the trickiest - and coolest - part came when my boss asked that it be fully backwards compatible.</p>
<p>Our flagship software application is heavily integrated with the web.  Users update their subscriptions through a web service.  Documents are downloaded from a webs service.  System updates are delivered through a web service.</p>
<p>Unfortunately, all of this was set up on a legacy server that was physically in our office.  Since we're moving to a distributed content hosting system, we needed an easy way not just to retrieve the data (that's handled already) but to send updates to these webservices.</p>
<p>It had to be secure.</p>
<p>It had to be fast.</p>
<p>It had to <em>not</em> be FTP.</p>
<h2>Last Time 'Round</h2>
<p>In my last job, I built a web service network that built off a traditional <a href="http://en.wikipedia.org/wiki/Challenge-response_authentication" target="_blank">challenge-response authentication</a> system.  Every client application accessed each web service on behalf of a specific user (with a username and password).  The client would ping the server and ask for a security token.  Then it would hash its credentials with the token and submit that hash along with the data.</p>
<p>Effective ... but bulky.</p>
<p>This older system required discrete user accounts be set up for <em>every user</em>.  It also required multiple HTTP transactions between systems - a HEAD request to get a token followed by a POST/GET/PUT/DELETE request to interact with data.  It worked, but was cumbersome.  The multiple transactions also opened us to man-in-the-middle attacks, so everything was necessarily SSL-encrypted.</p>
<h2>A New Paradigm</h2>
<p>This time, I elected to go with a simpler system that, oddly enough, is more secure.</p>
<p>The client is issued an application name and secret key at its time of deployment - the server keeps track of these in a secured database.  The secret key is <em>never</em> exchanged over the wire.</p>
<p>When a client sends a request, it also submits three pieces of information in the request headers:</p>
<ul>
<li>It's name</li>
<li>A randomly-generated string</li>
<li>A one-time password</li>
</ul>
<p>The one-time password is a hash of three things:</p>
<ul>
<li>The application's secret key</li>
<li>The same randomly-generated string passed in the header</li>
<li>The current system UNIX timestamp, divided by 15</li>
</ul>
<p>This ensures the password is unique to the application, unique to the request, and only valid within a narrow time window.</p>
<h2>Why It Works</h2>
<p>The server independently re-creates the application's password by looking up the application's secret key and hashing it together with the random string passed in the request and the current system UNIX timestamp (divided by 15).</p>
<p>The server will only accept requests for the current 15-second window and the immediately previous 15-second window.</p>
<p>In addition, the server records the random string sent by the application and automatically rejects any duplicate requests.</p>
<p>This leads to an authentication system that is:</p>
<ul>
<li>Unique to <em>client applications</em> but not necessarily to individual user accounts</li>
<li>Incredibly fast - only one request is ever sent/received</li>
<li>Not based on FTP</li>
</ul>
<p>What would you do to make the request <em>more</em> secure?</p>

        </div>
        <footer class="post-footer">
            <div class="post-share">
                <span class="post-share-title">Share:</span>
                <a target="_blank"
                    href="https://twitter.com/share?text=One+Time+Password+Security&amp;url=https://ttmm.iotech/one-time-password-security/">Twitter</a>
                <a target="_blank"
                    href="https://www.facebook.com/sharer/sharer.php?u=https://ttmm.iotech/one-time-password-security/">Facebook</a>
            </div><!-- .share-post -->
            
            <p class="post-cats">
                <span class="post-share-title">Filed under </span>
                <a href="/categories/index.html#Technology"
                    rel="category">Technology</a>
                
            </p>
            
            
            <p class="post-tags">
                <span class="post-share-title">Tagged with </span>
                <a href="/tags/index.html#.Net"
                    rel="tag">.Net</a>
                <a href="/tags/index.html#security"
                    rel="tag">security</a>
                
            </p>
            
        </footer>
        
    </article>
    
    <section class="read-next inner">
        <h2 class="read-next-title">Read Next</h2>
        
        <article class="post">
            <header class="post-header">
                <div class="post-meta">
                    <time class="published" datetime="September 23, 2011">September 23, 2011</time>
                </div>
                <h3 class="post-title"><a href="/tech/shortcuts-in-chrome/">Shortcuts in Chrome</a>
                </h3>
            </header>
        </article>
        
        
        <article class="post">
            <header class="post-header">
                <div class="post-meta">
                    <time class="published" datetime="September 30, 2011">September 30, 2011</time>
                </div>
                <h3 class="post-title"><a href="/tech/installing-a-new-engine-nginx/">Installing a New Engine - Nginx</a></h3>
            </header>
        </article>
        
    </section><!-- .read-next -->

</main><!-- .site-main -->


                

                
                <footer id="colophon" class="site-footer">
    <p class="site-info inner">
        <a href="#">Things that Matter Most</a> &copy; 2021. Royce theme by
        <a target="_blank" href="https://justgoodthemes.com/">JustGoodThemes</a>.
        <br />
        Powered by <a target="_blank" href="https://jekyllrb.com/">Jekyll</a>.
    </p>
    <a id="back-to-top" class="back-to-top" href="#page">
        <span class="icon-arrow-up" aria-hidden="true"></span>
        <span class="screen-reader-text">Back to top</span>
    </a>
</footer><!-- .site-footer -->
            </div><!-- .inner-wide -->
        </div><!-- .site-content -->
    </div><!-- .site -->

    
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-4156949-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-4156949-6', { 'anonymize_ip': true });
  </script>

    <!-- Javascript Assets -->
    <script src="/assets/js/jquery-3.3.1.min.js"></script>
    <script src="/assets/js/plugins.js"></script>
    <script src="/assets/js/custom.js"></script>

</body>

</html>