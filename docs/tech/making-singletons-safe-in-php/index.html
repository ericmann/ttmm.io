<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
        <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Making Singletons Safe in PHP | Things that Matter Most</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Making Singletons Safe in PHP" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Last time, I argued in favor of the Singleton pattern in WordPress. &nbsp;Singletons make sense in WordPress specifically for several reasons: They live in the global scope without using the already abused/overused [cci]global[/cci] keyword As a distributed application maintained by several hundred developers, they prevent problems that likely arise from others misusing your code But one of the goals of object-oriented software development is to make your code reusable. &nbsp;The Singleton pattern as I explained it last time isn&#39;t really applicable outside of WordPress. &nbsp;Typically, Singletons&nbsp;are a really bad idea. &nbsp;But rather than get hung up on the term and settle for the knee-jerk &quot;it&#39;s bad, don&#39;t use it&quot; conclusion, let&#39;s take a deeper look. &nbsp;There&#39;s a reason Singletons exist; they solve a specific problem. &nbsp;So rather than reject them out of hand, let&#39;s make a minor change to make them safe for general PHP use. There were two major arguments&nbsp;against Singletons throughout the comments, Twitter posts, Y Combinator thread, and private emails that followed my last post. First, that Singletons introduce hidden dependencies in your code. &nbsp;Second, that Singletons are nearly impossible to unit test. &nbsp;Both of these arguments are valid, but I have counters to each. Hidden Dependencies Any parameters a function accepts are visible dependencies. But if the function requires something else to operate - i.e. an open database connection - that is referenced through a global variable rather than a parameter, that dependency is considered hidden. There is no way for a third-party to know about that functional dependency without actually viewing the implementation of the function. Hidden dependencies make it extremely difficult to code against an API because the API isn&#39;t the whole story. As an application grows, it&#39;s easier and easier to take shortcuts to get things done. &nbsp;WordPress, for example, [cci]global[/cci]izes many of its internal variables. &nbsp;The entire post loop is set up specifically to abuse the fact that the [cci]$post[/cci] object is global: if ( have_posts() ) : while ( have_posts() ) : the_post(); // Populates global $post object&lt;/p&gt; // Filter and echo $post-&gt;post_title from the global $post the_title(); // Filter and echos $post-&gt;post_content from the global $post the_content(); endwhile; endif;&lt;/code&gt; To get around this hidden dependency, you inject it. &nbsp;Rather than referencing the global post object inside the function (a hidden dependency that you can&#39;t easily override at runtime), you pass a post object when you call the function. &nbsp;This post object can then be substituted with another at runtime and the code is none the wiser. // So instead of this function function do_something_to_post() { global $post;&lt;/p&gt; $post-&gt;post_content = apply_filters( &#39;modify_content&#39;, $post-&gt;post_content ); return $post; } // You&#39;d use this function and pass $post with the call. function do_something_to_post( $post ) { $post-&gt;post_content = apply_filters( &#39;modify_content&#39;, $post-&gt;post_content ); return $post; }&lt;/code&gt; Your business logic shouldn&#39;t ever have to know where the post object comes from, just what it looks like. &nbsp;Abstract that functionality away and you can provide any object you want - a post pulled from the database, one parsed from a document in the file system, or one hard-coded in a unit testing framework. In Singletons When developers use Singletons, they&#39;re often tempted to reference [cci]Singleton::get_instance()[/cci] directly (which is akin to invoking a global variable). Instead, code should accept a parameter and expect it to have a particular signature. &nbsp;In strictly typed languages like C and C#, you&#39;d do this by specifying an interface the object is required to implement. Dynamically typed languages like PHP don&#39;t require that[ref]Omitting type references in PHP is often considered &quot;duck typing.&quot; Basically, &quot;if it walks like a duck and talks like a duck, it&#39;s a duck.&quot; So if the object passed in implements the methods you plan to use, it might as well be of the type you expected ... even if it&#39;s something else. A function can accept an array, but I can just as easily pass it an object that implements [cci]ArrayAccess[/cci] and the function doesn&#39;t know the difference.[/ref], but it&#39;s a good idea to get in the habit anyway. &nbsp;It makes your intention clear to other developers and makes your code - and its dependencies - self-documenting. Instead of invoking our Singleton object inside the function, we pass in an object that implements the same interface as our Singleton: function save_data( IDatabase $db_connection ) { // The IDatabase interface specifies a persist() method. We don&#39;t // care what the object that gets passed in is, so long as it // conforms to the interface we expect to use. $db_connection-&gt;persist(); } $connection = DB::get_instance();&lt;/p&gt; save_data( $connection );&lt;/code&gt; The [cci]IDatabase[/cci] flag inside the function definition is what&#39;s called Type Hinting in PHP. It forces the passed parameter to be of the specified type - or for classes/interfaces to be a child or implementation of that type. It&#39;s not strictly required for dependency injection, but placing the type in the function call makes your intentions in the code crystal clear to the next developer who reads it. Unit Testing Every unit test should start from a clean slate. &nbsp;Ideally, unit test should run independent of the database and filesystem. &nbsp;This is actually my biggest problem with WordPress - since so many of its DB calls are hard-coded in the application, the unit test suite&nbsp;requires a database in order to run. &nbsp;Bad form. The problem with Singletons as I explained them in my last article is a global state - once they&#39;re instantiated, they stick around. &nbsp;Anything you do to a Singleton in one test is persisted and visible in other tests. &nbsp;This global state makes testing a mess, and my (lazy) solution was to introduce a [cci]::reset()[/cci] method that flushed the stored instance between tests. There&#39;s a better way. First, define the interface your Singleton object will implement. This isn&#39;t a strict requirement, but it&#39;s easy for other developers to look at an interface and grok the API you&#39;re exposing. Second, define an abstract class that implements this interface. Don&#39;t actually include any abstract functionality (unless you really want to). The point here is to have the business logic of your Singleton encapsulated in a way that can&#39;t be instantiated directly. Finally, define a Singleton class that extends the abstract business logic class. The Singleton wraps things up in a nice, can-only-be-instantiated-once wrapper. interface IDemo { function write( $file, $message );&lt;/p&gt; // These methods will be used to demonstrate state function increment( $step ); function get_counter(); } abstract class Abstract_Demo implements IDemo { protected $counter = 0; public function write( $file, $message ) { $fp = fopen( $file, &#39;a&#39; ); fwrite( $fp, $message . &quot;\r\n&quot; ); fclose( $fp ); } public function increment( $step ) { $this-&gt;counter += $step; } public function get_counter() { return $this-&gt;counter; } } final class Singleton_Demo extends Abstract_Demo { private static $instance = null; private function __construct() {} public static function get_instance() { if ( null == self::$instance ) { self::$instance = new self; } return self::$instance; } } $logger = Singleton_Demo::get_instance(); $logger-&gt;write( &#39;file.txt&#39;, &#39;This writes out to a file.&#39; );&lt;/code&gt; The incredibly basic example above introduces an interface to document the signature of our class, an abstract class to implement the business logic, and a final class to instantiate that logic. &nbsp;As an abstract class cannot be directly instantiated, there&#39;s no danger of anyone doing so without going through our Singleton. &nbsp;In our live application, the Singleton prevents any other developers from accidentally making more than one copy of our class. When it comes time to test, though, the unit test project can extend the class the same way the Singleton does, but with a public constructor. &nbsp;Now, within our unit test suite, we can create a&nbsp;new instance of our class for every single test. class Concrete_Demo extends Abstract_Demo { public function __construct() {} }&lt;/p&gt; $logger = new Test_Demo(); $logger-&gt;write( &#39;file.txt&#39;, &#39;This also writes out.&#39; );&lt;/code&gt; Since our multiple-instance class implements the same interface as our Singleton, we can substitute it for our Singleton in whatever methods rely upon it. Testing the business logic used by our Singleton is also fairly straight-forward using this concrete class. Below is an example set of 4 unit tests. The first two illustrate the conflict presented by testing Singletons - the state set up by the first test bleeds over into and corrupts the second. The later two illustrate using a concrete extension of our abstract class to allow multiple-instantiation within our test suite. class Demo_Test extends PHPUnit_Framework_TestCase { public function testSingletonDemo() { $singleton = Singleton_Demo::get_instance();&lt;/p&gt; $this-&gt;assertEquals( 0, $singleton-&gt;get_counter() ); $singleton-&gt;increment( 5 ); $this-&gt;assertEquals( 5, $singleton-&gt;get_counter() ); } public function testSingletonDemoState() { $singleton = Singleton_Demo::get_instance(); // A new test should start with a new state. But since we // manipulated our singleton in the last test, it already // has an internal state. This test will FAIL if run after // the preceding test. This illustrates why most developers // hate Singletons. $this-&gt;assertEquals( 0, $singleton-&gt;get_counter() ); } public function testConcreteDemo() { $obj = new Concrete_Demo; $this-&gt;assertEquals( 0, $obj-&gt;get_counter() ); $obj-&gt;increment( 5 ); $this-&gt;assertEquals( 5, $obj-&gt;get_counter() ); } public function testConcreteDemoState() { $obj = new Concrete_Demo; // We&#39;re testing a new instance, so the internal counter // is once again set to 0. $this-&gt;assertEquals( 0, $obj-&gt;get_counter() ); } } // This class is included ONLY in the test suite. Not the live // application. That way it&#39;s never accidentally used. class Concrete_Demo extends Abstract_Demo { public function __construct() {} }&lt;/code&gt; Conclusion The point of using a Singleton is to: Ensure only one instance of your class ever exists Provide a global entry point or reference to that instance of the class Yes, most people (including myself) disdain global variables. &nbsp;But we use them all over the place. &nbsp;Consider what a PHP web application would look like without [cci]$_GET[/cci] or [cci]$_COOKIE[/cci]. &nbsp;These are global variables that are baked in to the language, yet they slip our minds whenever we start the &quot;all global variables are evil and developers who use them are too naive to know better&quot; arguments. Consider also the static [cci]Request[/cci] and [cci]Response[/cci] classes in C#. &nbsp;They serve a similar purpose - only one instance of each exists, and they provide global entry points/references for the application. &nbsp;You&nbsp;can&nbsp;create and use your own versions, but only through the behind-the-scenes [cci]HttpRequestBase[/cci] and [cci]HttpResponseBase[/cci] classes, which are both abstract serve a similar purpose as my abstract class above. People hate Singletons not because Singletons are inherently bad, but because so many developers have used them too often and in improper scenarios. &nbsp;If you take care in developing your application, you can use Singletons safely without introducing hidden dependencies and while still maintaining a properly unit-testable application." />
<meta property="og:description" content="Last time, I argued in favor of the Singleton pattern in WordPress. &nbsp;Singletons make sense in WordPress specifically for several reasons: They live in the global scope without using the already abused/overused [cci]global[/cci] keyword As a distributed application maintained by several hundred developers, they prevent problems that likely arise from others misusing your code But one of the goals of object-oriented software development is to make your code reusable. &nbsp;The Singleton pattern as I explained it last time isn&#39;t really applicable outside of WordPress. &nbsp;Typically, Singletons&nbsp;are a really bad idea. &nbsp;But rather than get hung up on the term and settle for the knee-jerk &quot;it&#39;s bad, don&#39;t use it&quot; conclusion, let&#39;s take a deeper look. &nbsp;There&#39;s a reason Singletons exist; they solve a specific problem. &nbsp;So rather than reject them out of hand, let&#39;s make a minor change to make them safe for general PHP use. There were two major arguments&nbsp;against Singletons throughout the comments, Twitter posts, Y Combinator thread, and private emails that followed my last post. First, that Singletons introduce hidden dependencies in your code. &nbsp;Second, that Singletons are nearly impossible to unit test. &nbsp;Both of these arguments are valid, but I have counters to each. Hidden Dependencies Any parameters a function accepts are visible dependencies. But if the function requires something else to operate - i.e. an open database connection - that is referenced through a global variable rather than a parameter, that dependency is considered hidden. There is no way for a third-party to know about that functional dependency without actually viewing the implementation of the function. Hidden dependencies make it extremely difficult to code against an API because the API isn&#39;t the whole story. As an application grows, it&#39;s easier and easier to take shortcuts to get things done. &nbsp;WordPress, for example, [cci]global[/cci]izes many of its internal variables. &nbsp;The entire post loop is set up specifically to abuse the fact that the [cci]$post[/cci] object is global: if ( have_posts() ) : while ( have_posts() ) : the_post(); // Populates global $post object&lt;/p&gt; // Filter and echo $post-&gt;post_title from the global $post the_title(); // Filter and echos $post-&gt;post_content from the global $post the_content(); endwhile; endif;&lt;/code&gt; To get around this hidden dependency, you inject it. &nbsp;Rather than referencing the global post object inside the function (a hidden dependency that you can&#39;t easily override at runtime), you pass a post object when you call the function. &nbsp;This post object can then be substituted with another at runtime and the code is none the wiser. // So instead of this function function do_something_to_post() { global $post;&lt;/p&gt; $post-&gt;post_content = apply_filters( &#39;modify_content&#39;, $post-&gt;post_content ); return $post; } // You&#39;d use this function and pass $post with the call. function do_something_to_post( $post ) { $post-&gt;post_content = apply_filters( &#39;modify_content&#39;, $post-&gt;post_content ); return $post; }&lt;/code&gt; Your business logic shouldn&#39;t ever have to know where the post object comes from, just what it looks like. &nbsp;Abstract that functionality away and you can provide any object you want - a post pulled from the database, one parsed from a document in the file system, or one hard-coded in a unit testing framework. In Singletons When developers use Singletons, they&#39;re often tempted to reference [cci]Singleton::get_instance()[/cci] directly (which is akin to invoking a global variable). Instead, code should accept a parameter and expect it to have a particular signature. &nbsp;In strictly typed languages like C and C#, you&#39;d do this by specifying an interface the object is required to implement. Dynamically typed languages like PHP don&#39;t require that[ref]Omitting type references in PHP is often considered &quot;duck typing.&quot; Basically, &quot;if it walks like a duck and talks like a duck, it&#39;s a duck.&quot; So if the object passed in implements the methods you plan to use, it might as well be of the type you expected ... even if it&#39;s something else. A function can accept an array, but I can just as easily pass it an object that implements [cci]ArrayAccess[/cci] and the function doesn&#39;t know the difference.[/ref], but it&#39;s a good idea to get in the habit anyway. &nbsp;It makes your intention clear to other developers and makes your code - and its dependencies - self-documenting. Instead of invoking our Singleton object inside the function, we pass in an object that implements the same interface as our Singleton: function save_data( IDatabase $db_connection ) { // The IDatabase interface specifies a persist() method. We don&#39;t // care what the object that gets passed in is, so long as it // conforms to the interface we expect to use. $db_connection-&gt;persist(); } $connection = DB::get_instance();&lt;/p&gt; save_data( $connection );&lt;/code&gt; The [cci]IDatabase[/cci] flag inside the function definition is what&#39;s called Type Hinting in PHP. It forces the passed parameter to be of the specified type - or for classes/interfaces to be a child or implementation of that type. It&#39;s not strictly required for dependency injection, but placing the type in the function call makes your intentions in the code crystal clear to the next developer who reads it. Unit Testing Every unit test should start from a clean slate. &nbsp;Ideally, unit test should run independent of the database and filesystem. &nbsp;This is actually my biggest problem with WordPress - since so many of its DB calls are hard-coded in the application, the unit test suite&nbsp;requires a database in order to run. &nbsp;Bad form. The problem with Singletons as I explained them in my last article is a global state - once they&#39;re instantiated, they stick around. &nbsp;Anything you do to a Singleton in one test is persisted and visible in other tests. &nbsp;This global state makes testing a mess, and my (lazy) solution was to introduce a [cci]::reset()[/cci] method that flushed the stored instance between tests. There&#39;s a better way. First, define the interface your Singleton object will implement. This isn&#39;t a strict requirement, but it&#39;s easy for other developers to look at an interface and grok the API you&#39;re exposing. Second, define an abstract class that implements this interface. Don&#39;t actually include any abstract functionality (unless you really want to). The point here is to have the business logic of your Singleton encapsulated in a way that can&#39;t be instantiated directly. Finally, define a Singleton class that extends the abstract business logic class. The Singleton wraps things up in a nice, can-only-be-instantiated-once wrapper. interface IDemo { function write( $file, $message );&lt;/p&gt; // These methods will be used to demonstrate state function increment( $step ); function get_counter(); } abstract class Abstract_Demo implements IDemo { protected $counter = 0; public function write( $file, $message ) { $fp = fopen( $file, &#39;a&#39; ); fwrite( $fp, $message . &quot;\r\n&quot; ); fclose( $fp ); } public function increment( $step ) { $this-&gt;counter += $step; } public function get_counter() { return $this-&gt;counter; } } final class Singleton_Demo extends Abstract_Demo { private static $instance = null; private function __construct() {} public static function get_instance() { if ( null == self::$instance ) { self::$instance = new self; } return self::$instance; } } $logger = Singleton_Demo::get_instance(); $logger-&gt;write( &#39;file.txt&#39;, &#39;This writes out to a file.&#39; );&lt;/code&gt; The incredibly basic example above introduces an interface to document the signature of our class, an abstract class to implement the business logic, and a final class to instantiate that logic. &nbsp;As an abstract class cannot be directly instantiated, there&#39;s no danger of anyone doing so without going through our Singleton. &nbsp;In our live application, the Singleton prevents any other developers from accidentally making more than one copy of our class. When it comes time to test, though, the unit test project can extend the class the same way the Singleton does, but with a public constructor. &nbsp;Now, within our unit test suite, we can create a&nbsp;new instance of our class for every single test. class Concrete_Demo extends Abstract_Demo { public function __construct() {} }&lt;/p&gt; $logger = new Test_Demo(); $logger-&gt;write( &#39;file.txt&#39;, &#39;This also writes out.&#39; );&lt;/code&gt; Since our multiple-instance class implements the same interface as our Singleton, we can substitute it for our Singleton in whatever methods rely upon it. Testing the business logic used by our Singleton is also fairly straight-forward using this concrete class. Below is an example set of 4 unit tests. The first two illustrate the conflict presented by testing Singletons - the state set up by the first test bleeds over into and corrupts the second. The later two illustrate using a concrete extension of our abstract class to allow multiple-instantiation within our test suite. class Demo_Test extends PHPUnit_Framework_TestCase { public function testSingletonDemo() { $singleton = Singleton_Demo::get_instance();&lt;/p&gt; $this-&gt;assertEquals( 0, $singleton-&gt;get_counter() ); $singleton-&gt;increment( 5 ); $this-&gt;assertEquals( 5, $singleton-&gt;get_counter() ); } public function testSingletonDemoState() { $singleton = Singleton_Demo::get_instance(); // A new test should start with a new state. But since we // manipulated our singleton in the last test, it already // has an internal state. This test will FAIL if run after // the preceding test. This illustrates why most developers // hate Singletons. $this-&gt;assertEquals( 0, $singleton-&gt;get_counter() ); } public function testConcreteDemo() { $obj = new Concrete_Demo; $this-&gt;assertEquals( 0, $obj-&gt;get_counter() ); $obj-&gt;increment( 5 ); $this-&gt;assertEquals( 5, $obj-&gt;get_counter() ); } public function testConcreteDemoState() { $obj = new Concrete_Demo; // We&#39;re testing a new instance, so the internal counter // is once again set to 0. $this-&gt;assertEquals( 0, $obj-&gt;get_counter() ); } } // This class is included ONLY in the test suite. Not the live // application. That way it&#39;s never accidentally used. class Concrete_Demo extends Abstract_Demo { public function __construct() {} }&lt;/code&gt; Conclusion The point of using a Singleton is to: Ensure only one instance of your class ever exists Provide a global entry point or reference to that instance of the class Yes, most people (including myself) disdain global variables. &nbsp;But we use them all over the place. &nbsp;Consider what a PHP web application would look like without [cci]$_GET[/cci] or [cci]$_COOKIE[/cci]. &nbsp;These are global variables that are baked in to the language, yet they slip our minds whenever we start the &quot;all global variables are evil and developers who use them are too naive to know better&quot; arguments. Consider also the static [cci]Request[/cci] and [cci]Response[/cci] classes in C#. &nbsp;They serve a similar purpose - only one instance of each exists, and they provide global entry points/references for the application. &nbsp;You&nbsp;can&nbsp;create and use your own versions, but only through the behind-the-scenes [cci]HttpRequestBase[/cci] and [cci]HttpResponseBase[/cci] classes, which are both abstract serve a similar purpose as my abstract class above. People hate Singletons not because Singletons are inherently bad, but because so many developers have used them too often and in improper scenarios. &nbsp;If you take care in developing your application, you can use Singletons safely without introducing hidden dependencies and while still maintaining a properly unit-testable application." />
<meta property="og:site_name" content="Things that Matter Most" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-01-07T12:00:47-08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Making Singletons Safe in PHP" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Making Singletons Safe in PHP","dateModified":"2013-01-07T12:00:47-08:00","datePublished":"2013-01-07T12:00:47-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/tech/making-singletons-safe-in-php/"},"url":"/tech/making-singletons-safe-in-php/","description":"Last time, I argued in favor of the Singleton pattern in WordPress. &nbsp;Singletons make sense in WordPress specifically for several reasons: They live in the global scope without using the already abused/overused [cci]global[/cci] keyword As a distributed application maintained by several hundred developers, they prevent problems that likely arise from others misusing your code But one of the goals of object-oriented software development is to make your code reusable. &nbsp;The Singleton pattern as I explained it last time isn&#39;t really applicable outside of WordPress. &nbsp;Typically, Singletons&nbsp;are a really bad idea. &nbsp;But rather than get hung up on the term and settle for the knee-jerk &quot;it&#39;s bad, don&#39;t use it&quot; conclusion, let&#39;s take a deeper look. &nbsp;There&#39;s a reason Singletons exist; they solve a specific problem. &nbsp;So rather than reject them out of hand, let&#39;s make a minor change to make them safe for general PHP use. There were two major arguments&nbsp;against Singletons throughout the comments, Twitter posts, Y Combinator thread, and private emails that followed my last post. First, that Singletons introduce hidden dependencies in your code. &nbsp;Second, that Singletons are nearly impossible to unit test. &nbsp;Both of these arguments are valid, but I have counters to each. Hidden Dependencies Any parameters a function accepts are visible dependencies. But if the function requires something else to operate - i.e. an open database connection - that is referenced through a global variable rather than a parameter, that dependency is considered hidden. There is no way for a third-party to know about that functional dependency without actually viewing the implementation of the function. Hidden dependencies make it extremely difficult to code against an API because the API isn&#39;t the whole story. As an application grows, it&#39;s easier and easier to take shortcuts to get things done. &nbsp;WordPress, for example, [cci]global[/cci]izes many of its internal variables. &nbsp;The entire post loop is set up specifically to abuse the fact that the [cci]$post[/cci] object is global: if ( have_posts() ) : while ( have_posts() ) : the_post(); // Populates global $post object&lt;/p&gt; // Filter and echo $post-&gt;post_title from the global $post the_title(); // Filter and echos $post-&gt;post_content from the global $post the_content(); endwhile; endif;&lt;/code&gt; To get around this hidden dependency, you inject it. &nbsp;Rather than referencing the global post object inside the function (a hidden dependency that you can&#39;t easily override at runtime), you pass a post object when you call the function. &nbsp;This post object can then be substituted with another at runtime and the code is none the wiser. // So instead of this function function do_something_to_post() { global $post;&lt;/p&gt; $post-&gt;post_content = apply_filters( &#39;modify_content&#39;, $post-&gt;post_content ); return $post; } // You&#39;d use this function and pass $post with the call. function do_something_to_post( $post ) { $post-&gt;post_content = apply_filters( &#39;modify_content&#39;, $post-&gt;post_content ); return $post; }&lt;/code&gt; Your business logic shouldn&#39;t ever have to know where the post object comes from, just what it looks like. &nbsp;Abstract that functionality away and you can provide any object you want - a post pulled from the database, one parsed from a document in the file system, or one hard-coded in a unit testing framework. In Singletons When developers use Singletons, they&#39;re often tempted to reference [cci]Singleton::get_instance()[/cci] directly (which is akin to invoking a global variable). Instead, code should accept a parameter and expect it to have a particular signature. &nbsp;In strictly typed languages like C and C#, you&#39;d do this by specifying an interface the object is required to implement. Dynamically typed languages like PHP don&#39;t require that[ref]Omitting type references in PHP is often considered &quot;duck typing.&quot; Basically, &quot;if it walks like a duck and talks like a duck, it&#39;s a duck.&quot; So if the object passed in implements the methods you plan to use, it might as well be of the type you expected ... even if it&#39;s something else. A function can accept an array, but I can just as easily pass it an object that implements [cci]ArrayAccess[/cci] and the function doesn&#39;t know the difference.[/ref], but it&#39;s a good idea to get in the habit anyway. &nbsp;It makes your intention clear to other developers and makes your code - and its dependencies - self-documenting. Instead of invoking our Singleton object inside the function, we pass in an object that implements the same interface as our Singleton: function save_data( IDatabase $db_connection ) { // The IDatabase interface specifies a persist() method. We don&#39;t // care what the object that gets passed in is, so long as it // conforms to the interface we expect to use. $db_connection-&gt;persist(); } $connection = DB::get_instance();&lt;/p&gt; save_data( $connection );&lt;/code&gt; The [cci]IDatabase[/cci] flag inside the function definition is what&#39;s called Type Hinting in PHP. It forces the passed parameter to be of the specified type - or for classes/interfaces to be a child or implementation of that type. It&#39;s not strictly required for dependency injection, but placing the type in the function call makes your intentions in the code crystal clear to the next developer who reads it. Unit Testing Every unit test should start from a clean slate. &nbsp;Ideally, unit test should run independent of the database and filesystem. &nbsp;This is actually my biggest problem with WordPress - since so many of its DB calls are hard-coded in the application, the unit test suite&nbsp;requires a database in order to run. &nbsp;Bad form. The problem with Singletons as I explained them in my last article is a global state - once they&#39;re instantiated, they stick around. &nbsp;Anything you do to a Singleton in one test is persisted and visible in other tests. &nbsp;This global state makes testing a mess, and my (lazy) solution was to introduce a [cci]::reset()[/cci] method that flushed the stored instance between tests. There&#39;s a better way. First, define the interface your Singleton object will implement. This isn&#39;t a strict requirement, but it&#39;s easy for other developers to look at an interface and grok the API you&#39;re exposing. Second, define an abstract class that implements this interface. Don&#39;t actually include any abstract functionality (unless you really want to). The point here is to have the business logic of your Singleton encapsulated in a way that can&#39;t be instantiated directly. Finally, define a Singleton class that extends the abstract business logic class. The Singleton wraps things up in a nice, can-only-be-instantiated-once wrapper. interface IDemo { function write( $file, $message );&lt;/p&gt; // These methods will be used to demonstrate state function increment( $step ); function get_counter(); } abstract class Abstract_Demo implements IDemo { protected $counter = 0; public function write( $file, $message ) { $fp = fopen( $file, &#39;a&#39; ); fwrite( $fp, $message . &quot;\\r\\n&quot; ); fclose( $fp ); } public function increment( $step ) { $this-&gt;counter += $step; } public function get_counter() { return $this-&gt;counter; } } final class Singleton_Demo extends Abstract_Demo { private static $instance = null; private function __construct() {} public static function get_instance() { if ( null == self::$instance ) { self::$instance = new self; } return self::$instance; } } $logger = Singleton_Demo::get_instance(); $logger-&gt;write( &#39;file.txt&#39;, &#39;This writes out to a file.&#39; );&lt;/code&gt; The incredibly basic example above introduces an interface to document the signature of our class, an abstract class to implement the business logic, and a final class to instantiate that logic. &nbsp;As an abstract class cannot be directly instantiated, there&#39;s no danger of anyone doing so without going through our Singleton. &nbsp;In our live application, the Singleton prevents any other developers from accidentally making more than one copy of our class. When it comes time to test, though, the unit test project can extend the class the same way the Singleton does, but with a public constructor. &nbsp;Now, within our unit test suite, we can create a&nbsp;new instance of our class for every single test. class Concrete_Demo extends Abstract_Demo { public function __construct() {} }&lt;/p&gt; $logger = new Test_Demo(); $logger-&gt;write( &#39;file.txt&#39;, &#39;This also writes out.&#39; );&lt;/code&gt; Since our multiple-instance class implements the same interface as our Singleton, we can substitute it for our Singleton in whatever methods rely upon it. Testing the business logic used by our Singleton is also fairly straight-forward using this concrete class. Below is an example set of 4 unit tests. The first two illustrate the conflict presented by testing Singletons - the state set up by the first test bleeds over into and corrupts the second. The later two illustrate using a concrete extension of our abstract class to allow multiple-instantiation within our test suite. class Demo_Test extends PHPUnit_Framework_TestCase { public function testSingletonDemo() { $singleton = Singleton_Demo::get_instance();&lt;/p&gt; $this-&gt;assertEquals( 0, $singleton-&gt;get_counter() ); $singleton-&gt;increment( 5 ); $this-&gt;assertEquals( 5, $singleton-&gt;get_counter() ); } public function testSingletonDemoState() { $singleton = Singleton_Demo::get_instance(); // A new test should start with a new state. But since we // manipulated our singleton in the last test, it already // has an internal state. This test will FAIL if run after // the preceding test. This illustrates why most developers // hate Singletons. $this-&gt;assertEquals( 0, $singleton-&gt;get_counter() ); } public function testConcreteDemo() { $obj = new Concrete_Demo; $this-&gt;assertEquals( 0, $obj-&gt;get_counter() ); $obj-&gt;increment( 5 ); $this-&gt;assertEquals( 5, $obj-&gt;get_counter() ); } public function testConcreteDemoState() { $obj = new Concrete_Demo; // We&#39;re testing a new instance, so the internal counter // is once again set to 0. $this-&gt;assertEquals( 0, $obj-&gt;get_counter() ); } } // This class is included ONLY in the test suite. Not the live // application. That way it&#39;s never accidentally used. class Concrete_Demo extends Abstract_Demo { public function __construct() {} }&lt;/code&gt; Conclusion The point of using a Singleton is to: Ensure only one instance of your class ever exists Provide a global entry point or reference to that instance of the class Yes, most people (including myself) disdain global variables. &nbsp;But we use them all over the place. &nbsp;Consider what a PHP web application would look like without [cci]$_GET[/cci] or [cci]$_COOKIE[/cci]. &nbsp;These are global variables that are baked in to the language, yet they slip our minds whenever we start the &quot;all global variables are evil and developers who use them are too naive to know better&quot; arguments. Consider also the static [cci]Request[/cci] and [cci]Response[/cci] classes in C#. &nbsp;They serve a similar purpose - only one instance of each exists, and they provide global entry points/references for the application. &nbsp;You&nbsp;can&nbsp;create and use your own versions, but only through the behind-the-scenes [cci]HttpRequestBase[/cci] and [cci]HttpResponseBase[/cci] classes, which are both abstract serve a similar purpose as my abstract class above. People hate Singletons not because Singletons are inherently bad, but because so many developers have used them too often and in improper scenarios. &nbsp;If you take care in developing your application, you can use Singletons safely without introducing hidden dependencies and while still maintaining a properly unit-testable application.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    

    <!-- Site Favicon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" type="image/png" />

    <!-- Font Embed Code -->
	<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,400i,600,600i|Karla:400,400i,700,700i" rel="stylesheet">

    <!-- CSS Styles -->
    <link href="/assets/css/style.css" rel="stylesheet">
</head>



<body class="layout-post">
    <div id="page" class="site">
        <header id="masthead" class="site-header">
    <div class="site-header-wrap">
        <div class="site-header-inside">

            <div class="site-branding">
                
                <p class="profile">
                    <a href="/">
                        <img src="/assets/images/authorimage.jpg" alt="'s Picture"
                            class="avatar" />
                    </a>
                </p>
                <div class="site-identity">
                    
                    <h1 class="site-title">
                        <a href="/">Things that Matter Most</a>
                    </h1>
                    
                    
                    <p class="site-description">Things that Matter Most</p>
                    
                </div><!-- .site-identity -->
                
                <button id="menu-toggle" class="menu-toggle"><span class="screen-reader-text">Main Menu</span><span
                        class="icon-menu" aria-hidden="true"></span></button>
            </div><!-- .site-branding -->

            <nav id="main-navigation" class="site-navigation" aria-label="Main Navigation">
                <div class="site-nav-wrap">
                    <div class="site-nav-inside">
                    <ul class="menu">
                        
                        
                        
                        <li class="menu-item "><a href="/">Home</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/about">About</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/contact">Contact Me</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/search">Search</a></li>
                        
                    </ul>
                    <p class="social-links">
    
    <a href="https://twitter.com/ericmann" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
    <a href="https://github.com/ericmann" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
    
    
    
    
    <a href="https://www.linkedin.com/in/ericallenmann" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
</p>
                    </div><!-- .site-nav-inside -->
                </div><!-- .site-nav-wrap -->
            </nav><!-- .site-navigation -->

        </div><!-- .site-header-inside -->
    </div><!-- .site-header-wrap -->
</header><!-- .site-header -->
        <div id="content" class="site-content fadeInDown delay_075s">
            <div class="inner-wide">
                <main id="main" class="site-main">

    <article class="post-full inner">

        <header class="post-header">
            <div class="post-meta">
                <time class="post-date" datetime="2013-01-07">
                    January 7, 2013
                </time>
            </div><!-- .post-meta -->
            <h1 class="post-title">Making Singletons Safe in PHP</h1>
        </header><!-- .post-header -->

        
        <div class="post-content">
            <p><a title="The Case for Singletons in WordPress" href="http://eamann.com/tech/the-case-for-singletons/">Last time</a>, I argued in favor of the Singleton pattern in WordPress. &nbsp;Singletons make sense in WordPress specifically for several reasons:</p>
<ul>
<li>They live in the global scope without using the already abused/overused [cci]global[/cci] keyword</li>
<li>As a distributed application maintained by several hundred developers, they prevent problems that likely arise from others misusing your code</li>
</ul>
<p>But one of the goals of object-oriented software development is to make your code reusable. &nbsp;The Singleton pattern as I explained it last time isn't really applicable outside of WordPress. &nbsp;Typically, Singletons&nbsp;<em>are</em> a really bad idea. &nbsp;But rather than get hung up on the term and settle for the knee-jerk "it's bad, don't use it" conclusion, let's take a deeper look. &nbsp;There's a reason Singletons exist; they solve a specific problem. &nbsp;So rather than reject them out of hand, let's make a minor change to make them safe for general PHP use.</p>
<p>There were two major arguments&nbsp;<em>against</em> Singletons throughout the comments, Twitter posts, <a title="The Case for Singletons | Hacker News" href="http://news.ycombinator.com/item?id=4978365">Y Combinator thread</a>, and private emails that followed my last post. First, that Singletons introduce hidden dependencies in your code. &nbsp;Second, that Singletons are nearly impossible to unit test. &nbsp;Both of these arguments are valid, but I have counters to each.<!--more--></p>
<h2>Hidden Dependencies</h2>
<p>Any parameters a function accepts are visible dependencies. But if the function requires something else to operate - i.e. an open database connection - that is referenced through a global variable rather than a parameter, <a href="http://tutorials.jenkov.com/ood/understanding-dependencies.html#visiblehidden" title="Understanding Dependencies">that dependency is considered <em>hidden</em></a>. There is no way for a third-party to know about that functional dependency without actually viewing the implementation of the function. Hidden dependencies make it extremely difficult to code against an API because the API isn't the whole story.</p>
<p>As an application grows, it's easier and easier to take shortcuts to get things done. &nbsp;WordPress, for example, [cci]global[/cci]izes many of its internal variables. &nbsp;The entire <a title="The Loop | WordPress Codex" href="http://codex.wordpress.org/The_Loop">post loop</a> is set up specifically to abuse the fact that the [cci]$post[/cci] object is global:</p>
<p><code lang="php">if ( have_posts() ) : while ( have_posts() ) :<br />
  the_post(); // Populates global $post object</p>
<p>  // Filter and echo $post->post_title from the global $post<br />
  the_title();</p>
<p>  // Filter and echos $post->post_content from the global $post<br />
  the_content();</p>
<p>endwhile; endif;</code></p>
<p>To get around this hidden dependency, you <a title="Dependency Injection" href="http://en.wikipedia.org/wiki/Dependency_injection">inject</a> it. &nbsp;Rather than referencing the global post object inside the function (a hidden dependency that you can't easily override at runtime), you pass a post object when you call the function. &nbsp;This post object can then be substituted with another at runtime and the code is none the wiser.</p>
<p><code lang="php">// So instead of this function<br />
function do_something_to_post() {<br />
  global $post;</p>
<p>  $post->post_content = apply_filters( 'modify_content', $post->post_content );</p>
<p>  return $post;<br />
}</p>
<p>// You'd use this function and pass $post with the call.<br />
function do_something_to_post( $post ) {<br />
  $post->post_content = apply_filters( 'modify_content', $post->post_content );</p>
<p>  return $post;<br />
}</code></p>
<p>Your business logic shouldn't ever have to know where the post object comes from, just what it looks like. &nbsp;Abstract that functionality away and you can provide any object you want - a post pulled from the database, one parsed from a document in the file system, or one hard-coded in a unit testing framework.</p>
<h3>In Singletons</h3>
<p>When developers use Singletons, they're often tempted to reference [cci]Singleton::get_instance()[/cci] directly (which is akin to invoking a global variable).  Instead, code should accept a parameter and expect it to have a particular signature. &nbsp;In strictly typed languages like C and C#, you'd do this by specifying an interface the object is required to implement.</p>
<p>Dynamically typed languages like PHP don't require that[ref]Omitting type references in PHP is often considered "duck typing."  Basically, "if it walks like a duck and talks like a duck, it's a duck."  So if the object passed in implements the methods you plan to use, it might as well be of the type you expected ... even if it's something else.  A function can accept an array, but I can just as easily pass it an object that implements [cci]ArrayAccess[/cci] and the function doesn't know the difference.[/ref], but it's a good idea to get in the habit anyway. &nbsp;It makes your intention clear to other developers and makes your code - and its dependencies - self-documenting.  Instead of invoking our Singleton object <em>inside</em> the function, we pass in an object that implements the same interface as our Singleton:</p>
<p><code lang="php">function save_data( IDatabase $db_connection ) {<br />
  // The IDatabase interface specifies a persist() method. We don't<br />
  // care what the object that gets passed in is, so long as it<br />
  // conforms to the interface we expect to use.<br />
  $db_connection->persist();<br />
}<br />
$connection = DB::get_instance();</p>
<p>save_data( $connection );</code></p>
<p>The [cci]IDatabase[/cci] flag inside the function definition is what's called <a title="PHP: Type Hinting" href="http://php.net/manual/en/language.oop5.typehinting.php">Type Hinting</a> in PHP. It forces the passed parameter to be of the specified type - or for classes/interfaces to be a child or implementation of that type. It's not strictly required for dependency injection, but placing the type in the function call makes your intentions in the code crystal clear to the next developer who reads it.</p>
<h2>Unit Testing</h2>
<p>Every unit test should start from a clean slate. &nbsp;Ideally, unit test should run independent of the database and filesystem. &nbsp;This is actually my biggest problem with WordPress - since so many of its DB calls are hard-coded in the application, the unit test suite&nbsp;<em>requires</em> a database in order to run. &nbsp;Bad form.</p>
<p>The problem with Singletons as I explained them in my last article is a global state - once they're instantiated, they stick around. &nbsp;Anything you do to a Singleton in one test is persisted and visible in other tests. &nbsp;This global state makes testing a mess, and my (lazy) solution was to introduce a [cci]::reset()[/cci] method that flushed the stored instance between tests.</p>
<p>There's a better way.</p>
<p>First, define the interface your Singleton object will implement.  This isn't a strict requirement, but it's easy for other developers to look at an interface and grok the API you're exposing.</p>
<p>Second, define an <em>abstract</em> class that implements this interface.  Don't actually include any abstract functionality (unless you really want to).  The point here is to have the business logic of your Singleton encapsulated in a way that can't be instantiated directly.</p>
<p>Finally, define a Singleton class that <em>extends</em> the abstract business logic class.  The Singleton wraps things up in a nice, can-only-be-instantiated-once wrapper.</p>
<p><code lang="php">interface IDemo {<br />
  function write( $file, $message );</p>
<p>  // These methods will be used to demonstrate state<br />
  function increment( $step );<br />
  function get_counter();<br />
}</p>
<p>abstract class Abstract_Demo implements IDemo {<br />
  protected $counter = 0;</p>
<p>  public function write( $file, $message ) {<br />
    $fp = fopen( $file, 'a' );</p>
<p>    fwrite( $fp, $message . "\r\n" );</p>
<p>    fclose( $fp );<br />
  }</p>
<p>  public function increment( $step ) {<br />
    $this->counter += $step;<br />
  }</p>
<p>  public function get_counter() {<br />
    return $this->counter;<br />
  }<br />
}</p>
<p>final class Singleton_Demo extends Abstract_Demo {<br />
  private static $instance = null;</p>
<p>  private function __construct() {}</p>
<p>  public static function get_instance() {<br />
    if ( null == self::$instance ) {<br />
      self::$instance = new self;<br />
    }<br />
    return self::$instance;<br />
  }<br />
}</p>
<p>$logger = Singleton_Demo::get_instance();<br />
$logger->write( 'file.txt', 'This writes out to a file.' );</code></p>
<p>The incredibly basic example above introduces an interface to document the signature of our class, an abstract class to implement the business logic, and a final class to instantiate that logic. &nbsp;As an abstract class cannot be directly instantiated, there's no danger of anyone doing so without going through our Singleton. &nbsp;In our live application, the Singleton prevents any other developers from accidentally making more than one copy of our class.</p>
<p>When it comes time to test, though, the unit test project can extend the class the same way the Singleton does, but with a public constructor. &nbsp;Now, within our unit test suite, we can create a&nbsp;<em>new</em> instance of our class for every single test.</p>
<p><code lang="php">class Concrete_Demo extends Abstract_Demo {<br />
  public function __construct() {}<br />
}</p>
<p>$logger = new Test_Demo();<br />
$logger->write( 'file.txt', 'This also writes out.' );</code></p>
<p>Since our multiple-instance class implements the same interface as our Singleton, we can substitute it for our Singleton in whatever methods rely upon it.</p>
<p>Testing the business logic used by our Singleton is also fairly straight-forward using this concrete class.  Below is an example set of 4 unit tests.  The first two illustrate the conflict presented by testing Singletons - the state set up by the first test bleeds over into and corrupts the second.  The later two illustrate using a concrete extension of our abstract class to allow multiple-instantiation within our test suite.</p>
<p><code lang="php">class Demo_Test extends PHPUnit_Framework_TestCase {<br />
  public function testSingletonDemo() {<br />
    $singleton = Singleton_Demo::get_instance();</p>
<p>    $this->assertEquals( 0, $singleton->get_counter() );</p>
<p>    $singleton->increment( 5 );</p>
<p>    $this->assertEquals( 5, $singleton->get_counter() );<br />
  }</p>
<p>  public function testSingletonDemoState() {<br />
    $singleton = Singleton_Demo::get_instance();</p>
<p>    // A new test should start with a new state. But since we<br />
    // manipulated our singleton in the last test, it already<br />
    // has an internal state. This test will FAIL if run after<br />
    // the preceding test. This illustrates why most developers<br />
    // hate Singletons.<br />
    $this->assertEquals( 0, $singleton->get_counter() );<br />
  }</p>
<p>  public function testConcreteDemo() {<br />
    $obj = new Concrete_Demo;</p>
<p>    $this->assertEquals( 0, $obj->get_counter() );</p>
<p>    $obj->increment( 5 );</p>
<p>    $this->assertEquals( 5, $obj->get_counter() );<br />
  }</p>
<p>  public function testConcreteDemoState() {<br />
    $obj = new Concrete_Demo;</p>
<p>    // We're testing a new instance, so the internal counter<br />
    // is once again set to 0.<br />
    $this->assertEquals( 0, $obj->get_counter() );<br />
  }<br />
}</p>
<p>// This class is included ONLY in the test suite. Not the live<br />
// application. That way it's never accidentally used.<br />
class Concrete_Demo extends Abstract_Demo {<br />
  public function __construct() {}<br />
}</code></p>
<h2>Conclusion</h2>
<p>The point of using a Singleton is to:</p>
<ul>
<li>Ensure only one instance of your class ever exists</li>
<li>Provide a global entry point or reference to that instance of the class</li>
</ul>
<p>Yes, most people (including myself) disdain global variables. &nbsp;But we use them all over the place. &nbsp;Consider what a PHP web application would look like without [cci]$_GET[/cci] or [cci]$_COOKIE[/cci]. &nbsp;These are global variables that are baked in to the language, yet they slip our minds whenever we start the "all global variables are evil and developers who use them are too naive to know better" arguments.</p>
<p>Consider also the static [cci]Request[/cci] and [cci]Response[/cci] classes in C#. &nbsp;They serve a similar purpose - only one instance of each exists, and they provide global entry points/references for the application. &nbsp;You&nbsp;<em>can</em>&nbsp;create and use your own versions, but only through the behind-the-scenes <a title="System.Web.HttpRequestBase" href="http://msdn.microsoft.com/en-us/library/system.web.httprequestbase.aspx">[cci]HttpRequestBase[/cci]</a> and <a title="System.Web.HttpResponseBase" href="http://msdn.microsoft.com/en-us/library/system.web.httpresponsebase.aspx">[cci]HttpResponseBase[/cci]</a> classes, which are both abstract serve a similar purpose as my abstract class above.</p>
<p>People hate Singletons not because Singletons are inherently bad, but because so many developers have used them too often and in improper scenarios. &nbsp;If you take care in developing your application, you can use Singletons safely without introducing hidden dependencies and while still maintaining a properly unit-testable application.</p>

        </div>
        <footer class="post-footer">
            <div class="post-share">
                <span class="post-share-title">Share:</span>
                <a target="_blank"
                    href="https://twitter.com/share?text=Making+Singletons+Safe+in+PHP&amp;url=https://ttmm.iotech/making-singletons-safe-in-php/">Twitter</a>
                <a target="_blank"
                    href="https://www.facebook.com/sharer/sharer.php?u=https://ttmm.iotech/making-singletons-safe-in-php/">Facebook</a>
            </div><!-- .share-post -->
            
            <p class="post-cats">
                <span class="post-share-title">Filed under </span>
                <a href="/categories/index.html#Technology"
                    rel="category">Technology</a>
                
            </p>
            
            
            <p class="post-tags">
                <span class="post-share-title">Tagged with </span>
                <a href="/tags/index.html#Class"
                    rel="tag">Class</a>
                <a href="/tags/index.html#Dependency+Injection"
                    rel="tag">Dependency Injection</a>
                <a href="/tags/index.html#Duck+Typing"
                    rel="tag">Duck Typing</a>
                <a href="/tags/index.html#Global+Variable"
                    rel="tag">Global Variable</a>
                <a href="/tags/index.html#Method"
                    rel="tag">Method</a>
                <a href="/tags/index.html#Object-oriented+Programming"
                    rel="tag">Object-oriented Programming</a>
                <a href="/tags/index.html#PHP"
                    rel="tag">PHP</a>
                <a href="/tags/index.html#singleton"
                    rel="tag">singleton</a>
                <a href="/tags/index.html#Singleton+Pattern"
                    rel="tag">Singleton Pattern</a>
                <a href="/tags/index.html#Software+Design+Patterns"
                    rel="tag">Software Design Patterns</a>
                <a href="/tags/index.html#Unit+Test"
                    rel="tag">Unit Test</a>
                <a href="/tags/index.html#WordPress"
                    rel="tag">WordPress</a>
                <a href="/tags/index.html#Y+Combinator"
                    rel="tag">Y Combinator</a>
                
            </p>
            
        </footer>
        
    </article>
    
    <section class="read-next inner">
        <h2 class="read-next-title">Read Next</h2>
        
        <article class="post">
            <header class="post-header">
                <div class="post-meta">
                    <time class="published" datetime="January 7, 2013">January 7, 2013</time>
                </div>
                <h3 class="post-title"><a href="/faith/podcast-episode-1/">Podcast</a>
                </h3>
            </header>
        </article>
        
        
        <article class="post">
            <header class="post-header">
                <div class="post-meta">
                    <time class="published" datetime="January 14, 2013">January 14, 2013</time>
                </div>
                <h3 class="post-title"><a href="/faith/podcast-episode-2/">Podcast</a></h3>
            </header>
        </article>
        
    </section><!-- .read-next -->

</main><!-- .site-main -->


                

                
                <footer id="colophon" class="site-footer">
    <p class="site-info inner">
        <a href="#">Things that Matter Most</a> &copy; 2021. Royce theme by
        <a target="_blank" href="https://justgoodthemes.com/">JustGoodThemes</a>.
        <br />
        Powered by <a target="_blank" href="https://jekyllrb.com/">Jekyll</a>.
    </p>
    <a id="back-to-top" class="back-to-top" href="#page">
        <span class="icon-arrow-up" aria-hidden="true"></span>
        <span class="screen-reader-text">Back to top</span>
    </a>
</footer><!-- .site-footer -->
            </div><!-- .inner-wide -->
        </div><!-- .site-content -->
    </div><!-- .site -->

    
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-4156949-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-4156949-6', { 'anonymize_ip': true });
  </script>

    <!-- Javascript Assets -->
    <script src="/assets/js/jquery-3.3.1.min.js"></script>
    <script src="/assets/js/plugins.js"></script>
    <script src="/assets/js/custom.js"></script>

</body>

</html>